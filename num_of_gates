from qiskit.compiler import transpile
from qiskit.visualization import plot_gate_map
import matplotlib.pyplot as plt
from qiskit import QuantumCircuit
from qiskit import Aer, execute
from qiskit.circuit.random import random_circuit
import random
import os
from qiskit.providers.fake_provider import FakeSherbrooke
import re

# This sorts our ciruits in ascending ordering via number of qubits
num = re.compile(r'(\d+)')
def ascending_sort(val):
    split = num.split(val)
    split[1::2] = map(int, split[1::2])
    return split

# Path to the circuits stored locally
def file_reader(file_path):
    circuits = []
    directory = file_path
    for circuit in sorted(os.listdir(directory), key=ascending_sort):
        circuit_path = file_path + "/" + circuit
        if (circuit_path.endswith('.qasm')):
            print(circuit_path)
            qc = QuantumCircuit.from_qasm_file(circuit_path)
            circuits.append(qc)

    return circuits

# # Responsible for creating circuits of random size and depth
# for i in range(50):
#     num_qubits = random.randint(1,10)
#     depth = random.randint(1,10)
#     qc = random_circuit(num_qubits, depth, measure=True)
#     random_circuits.append(qc)

# random_circuits

# Select your backend (e.g., Aer's qasm_simulator)
backend = FakeSherbrooke()

# Read circuits from files
circuits = file_reader("tests")

# # Dictionary to store transpiled circuits for each optimization level
# transpiled_circuits = {3: [],
#                        2: [],
#                        1: []} 

# Transpile each circuit, count the gates, and store the results
gate_counts = []
for circuit in circuits:
    # stores the number of gates 
    transpiled_circuit = transpile(circuit, backend)
    gate_count = transpiled_circuit.count_ops()
    gate_counts.append(sum(gate_count.values()))


    # # stores the number of entangled gates 
    # entangled_gate_counts = []

    # for opt_level in [3, 2, 1]:
    #     transpiled_circuit = transpile(circuit, backend, optimization_level=opt_level)
    #     transpiled_circuits[opt_level].append(transpiled_circuit)

    #     # counts the number of gates in a given circuit
    #     gate_count = transpiled_circuit.count_ops()
    #     gate_counts.append(sum(gate_count.values()))

# Generate a graph to visualize the gate counts

plt.plot(range(1, len(circuits) + 1), gate_counts, marker='o')
plt.xlabel('Circuit')
plt.ylabel('Gate Count')
plt.title('Gate Count of Transpiled Circuits')
plt.xticks(range(1, len(circuits) + 1))
plt.show()

# gate_counts = []
# for circuit in circuits: #os.listdir(circuit_tests_path) if we used a file with random circuits ready to be tested
#     #circuit = os.path.join(circuit, circuit_tests_path)
#     transpiled_circuit = transpile(circuit, backend)
#     gate_count = transpiled_circuit.count_ops()
#     gate_counts.append(sum(gate_count.values()))

# # Generate a graph to visualize the gate counts
# plt.plot(range(1, len(circuits) + 1), gate_counts, marker='o')
# plt.xlabel('Circuit')
# plt.ylabel('Gate Count')
# plt.title('Gate Count of Transpiled Circuits')
# plt.xticks(range(1, len(circuits) + 1))
# plt.show()
